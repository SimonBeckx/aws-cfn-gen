# How to use Docker image `ixor/ansible-aws-cfn-gen`

## Description

Use a controlled environment to run the `aws-cfn-gen` _Ansible_ playbooks and
create or update the _AWS CloudFormation_ template on the AWS account of your
choice.

The choice of the docker image determines the versions of _Ansible_ and the _AWS CLI_,
while the environment variable `${GITTAG}` determines the version of `aws-cfn-gen` to
be used.

This allows the `aws-cfn-gen` code to evolve, without breaking compatibility with
existing configuration files and, more importantly, without causing changes to
already existing AWS resources created by _CloudFormation_ templates generated by
older versions of `aws-cfn-gen`.

## Usage

The use of the image is simple and straightforward, but there are some prerequisites:

### Required

* A _Docker_ on the machine where you will run the container
* A configuration file
* AWS authentication information has to be provided to the container.
  This can be done in several ways, see further down for more information.
* A volume mapping to `/config` should be included. That is the place
  where the container will look for the configuration file named `${CONFIG}`
* Environment variable `${CONFIG}` that specifies the name of the
  configuration to pass to tha `ansible-playbook` command.

### Optional

* Environment varialbe `${GITTAG}`. This will be used to checkout the tag
  of `aws-cfn-gen` that corresponds to the version of the configuration
  file `/config/${CONFIG}`. If `${GITTAG}` is not specified, `master` will
  be used.
* Environment variable `{$ANSIBLE_TAGS}`. This will limit the execution of
  the playbook to only the tags you specify.
* Environment variable `{$ANSIBLE_SKIPTAGS}`. This will limit the execution of
  the playbook and skip the tags you specify.

## AWS Authentication

### Use environment variables

You can pass your AWS authentication environment variables to the docker image
by adding them to the `docker run` commandline, like this:

```bash
    -e AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID} \
    -e AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}" \
    -e AWS_REGION=${AWS_REGION:-eu-central-1} \
    -e AWS_SESSION_TOKEN=${AWS_SESSION_TOKEN} \
```

### _Volume mount_ your `~/.aws` directory

Another way to authenticate is to mount your local `~/.aws` folder into
the Docker container.

To accomplish that, add this to the `docker run` commandline:

```bash
    -v ~/.aws:/root/.aws \
```

## Image Versioning Scheme

The version of the image if formatted like this:

```
a.b.c-aws-d.e
```

Where:

* `a.b.c` is the version of _Ansible_ in the image
* `d.e` is the version of `awscli` in the image (this is the latest `d.e`
  release that was available at the time the docker image was built)

## Example

```bash
$ cat dockerwrapper
#! /bin/bash

export GITTAG=v0.1.0

docker run --rm \
    -e AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID} \
    -e AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}" \
    -e AWS_REGION=${AWS_REGION:-eu-central-1} \
    -e AWS_SESSION_TOKEN=${AWS_SESSION_TOKEN} \
    -e GITTAG=${TAG:-v0.1.0} \
    -e ANSIBLE_TAGS=${ANSIBLE_TAGS:-} \
    -e ANSIBLE_SKIPTAGS=${ANSIBLE_SKIPTAGS:-} \
    -e CONFIG=config.yml \
    -v ${PWD}:/config \
    -it \
    ixor/ansible-aws-cfn-gen:2.6.1-aws-1.6
```

When the `dockerwrapper` script is started, it will produce output similar to
this:

```bash
$ ./dockerwrapper
Unable to find image 'tryxcom/ansibleaws:latest' locally
latest: Pulling from tryxcom/ansibleaws
...
7418f6920929: Already exists
b8c825a4e1d5: Pull complete
Digest: sha256:0f8732fce4d921b2e9962ccf3a2da623c7db768f69536e1c00dc4014ba4b97aa
Status: Downloaded newer image for tryxcom/ansibleaws:latest
Cloning into 'aws-cfn-gen'...
remote: Counting objects: 209, done.
remote: Compressing objects: 100% (33/33), done.
remote: Total 209 (delta 50), reused 69 (delta 45), pack-reused 131
Receiving objects: 100% (209/209), 48.55 KiB | 464.00 KiB/s, done.
Resolving deltas: 100% (118/118), done.
Note: checking out 'v0.1.0'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b <new-branch-name>

HEAD is now at 4b59821 with_items should not be on block level (ALB)
 [WARNING]: Found variable using reserved name: roles


PLAY [Create a complete Application Environment on AWS] **********************************************************************

TASK [Test AWS_REGION] **********************************************************************
ok: [localhost]

TASK [Test AWS_SECRET_ACCESS_KEY] **********************************************************************
ok: [localhost]
...

```

## Links and Resources

* https://github.com/rik2803/aws-cfn-gen

