AWSTemplateFormatVersion: '2010-09-09'

Description: |
  Create an ECS stack {{ project }}

### For latest ECS optomized AMIs: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html
Mappings:
  AWSRegionToAMI:
    eu-central-1:
      AMIID: ami-10e6c8fb
    eu-west-1:
      AMIID: ami-c91624b0
    eu-west-2:
      AMIID: ami-3622cf51
    eu-west-3:
      AMIID: ami-ca75c4b7

Resources:

  ### AWS::IAM::Role and AWS::IAM::InstanceProfile
  ECSServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
      - PolicyName: ecs-service
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action: ['elasticloadbalancing:DeregisterInstancesFromLoadBalancer', 'elasticloadbalancing:DeregisterTargets',
              'elasticloadbalancing:Describe*', 'elasticloadbalancing:RegisterInstancesWithLoadBalancer',
              'elasticloadbalancing:RegisterTargets', 'ec2:Describe*', 'ec2:AuthorizeSecurityGroupIngress']
            Resource: '*'
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ec2.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"

      Policies:
      - PolicyName: ecs-service
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action: ['ecs:CreateCluster', 'ecs:DeregisterContainerInstance', 'ecs:DiscoverPollEndpoint',
              'ecs:Poll', 'ecs:RegisterContainerInstance', 'ecs:StartTelemetrySession',
              'ecs:Submit*', 'logs:CreateLogStream', 'logs:PutLogEvents', 'ecr:GetAuthorizationToken' ]
            Resource: '*'


#  ### Default CloudWatch alerts and ScalingPolicies for ECS cluster
#  ECSCPUReservationAlarm70Up:
#    Type: AWS::CloudWatch::Alarm
#    Properties:
#      ### AlarmName: Do not use AlarmName because changing it requires replacing the resource
#      AlarmDescription: "Trigger when AWS/ECS CPUReservation is over 70 during the last 60 1 minute intervals"
#      EvaluationPeriods: '1'
#      Statistic: Maximum
#      Threshold: '70'
#      Period: '60'
#      AlarmActions:
#      - !Ref ECSCPUReservationScaleUpPolicy
#      Dimensions:
#      - Name: ClusterName
#        Value: !Ref ECSCluster
#      ComparisonOperator: GreaterThanThreshold
#      MetricName: CPUReservation
#      Namespace: AWS/ECS
#
#  ECSCPUReservationAlarm50Down:
#    Type: AWS::CloudWatch::Alarm
#    Properties:
#      ### AlarmName: Do not use AlarmName because changing it requires replacing the resource
#      AlarmDescription: "Trigger when AWS/ECS CPUReservation is over 50 during the last 5 1 minute intervals"
#      EvaluationPeriods: '5'
#      Statistic: Maximum
#      Threshold: '50'
#      Period: '60'
#      AlarmActions:
#      - !Ref ECSCPUReservationScaleDownPolicy
#      Dimensions:
#      - Name: ClusterName
#        Value: !Ref ECSCluster
#      ComparisonOperator: LessThanThreshold
#      MetricName: CPUReservation
#      Namespace: AWS/ECS
#
#  ECSCPUReservationScaleUpPolicy:
#    Type: AWS::AutoScaling::ScalingPolicy
#    Properties:
#      AdjustmentType: ChangeInCapacity
#      AutoScalingGroupName: !Ref ECSAutoScalingGroup
#      Cooldown: '300'
#      ScalingAdjustment: '1'
#
#  ECSCPUReservationScaleDownPolicy:
#    Type: AWS::AutoScaling::ScalingPolicy
#    Properties:
#      AdjustmentType: ChangeInCapacity
#      AutoScalingGroupName: !Ref ECSAutoScalingGroup
#      Cooldown: '300'
#      ScalingAdjustment: '-1'
#
#  ECSMemoryReservationAlarm70Up:
#    Type: AWS::CloudWatch::Alarm
#    Properties:
#      ### AlarmName: Do not use AlarmName because changing it requires replacing the resource
#      AlarmDescription: "Trigger when AWS/ECS MemoryReservation is over 70 during the last 1 minute interval"
#      EvaluationPeriods: '1'
#      Statistic: Maximum
#      Threshold: '70'
#      Period: '60'
#      AlarmActions:
#      - !Ref ECSMemoryReservationScaleUpPolicy
#      Dimensions:
#      - Name: ClusterName
#        Value: !Ref ECSCluster
#      ComparisonOperator: GreaterThanThreshold
#      MetricName: MemoryReservation
#      Namespace: AWS/ECS
#
#  ECSMemoryReservationAlarm50Down:
#    Type: AWS::CloudWatch::Alarm
#    Properties:
#      ### AlarmName: Do not use AlarmName because changing it requires replacing the resource
#      AlarmDescription: "Trigger when AWS/ECS MemoryReservation is under 50 during the last 5 1 minute intervals"
#      EvaluationPeriods: '5'
#      Statistic: Maximum
#      Threshold: '50'
#      Period: '60'
#      AlarmActions:
#      - !Ref ECSMemoryReservationScaleDownPolicy
#      Dimensions:
#      - Name: ClusterName
#        Value: !Ref ECSCluster
#      ComparisonOperator: LessThanThreshold
#      MetricName: MemoryReservation
#      Namespace: AWS/ECS
#
#  ECSMemoryReservationScaleUpPolicy:
#    Type: AWS::AutoScaling::ScalingPolicy
#    Properties:
#      AdjustmentType: ChangeInCapacity
#      AutoScalingGroupName: !Ref ECSAutoScalingGroup
#      Cooldown: '300'
#      ScalingAdjustment: '1'
#
#  ECSMemoryReservationScaleDownPolicy:
#    Type: AWS::AutoScaling::ScalingPolicy
#    Properties:
#      AdjustmentType: ChangeInCapacity
#      AutoScalingGroupName: !Ref ECSAutoScalingGroup
#      Cooldown: '300'
#      ScalingAdjustment: '-1'


  AutoscalingRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [application-autoscaling.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
      - PolicyName: service-autoscaling
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action: ['application-autoscaling:*', 'cloudwatch:DescribeAlarms', 'cloudwatch:PutMetricAlarm',
              'ecs:DescribeServices', 'ecs:UpdateService']
            Resource: '*'

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles: [!Ref 'EC2Role']

  ### Resources for the ECS Cluster and the Container Instances
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: "ecs-{{ project }}"

  LambdaCumulativeReservationMetric:
    Type: AWS::Lambda::Function
    Properties:
      Handler: ecs-cumulative-cpu-and-memory-reservation-metric.lambda_handler
      Role: !Sub "arn:aws:iam::${AWS::AccountId}:role/LambdaCloudWatchAndECSListExecutionRole"
      Environment:
        Variables:
          ECS_CLUSTER_NAME: "ecs-{{ project }}"
      Code:
        S3Bucket: "{{ lambda_function_bucket_name }}"
        S3Key: "aws-lambda-ecs-cumulative-cpu-and-memory-reservation-metric-aeb85f697f80b78ce88d81017d3d3b169bd088dd.zip"
      Runtime: python2.7

  LambdaPermissionCumulativeReservationMetric:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt LambdaCumulativeReservationMetric.Arn
      Action: 'lambda:InvokeFunction'
      Principal: events.amazonaws.com
      SourceArn: !ImportValue "IxorMonitoringSubaccount-ScheduledRule5minArn"

  EventRuleECSTaskStateChange:
    Type: "AWS::Events::Rule"
    Properties:
      Description: "EventRule"
      EventPattern:
        source:
          - aws.ecs
        detail-type:
          - ECS Task State Change
        detail:
          clusterArn:
            - !GetAtt ECSCluster.Arn
      Targets:
        - Arn: !ImportValue "IxorMonitoringSubaccount-MonitoringSNSTopic"
          Id: "TargetMonitoringSNSTopic"


  ContainerInstances:
    Type: AWS::AutoScaling::LaunchConfiguration
    Properties:
      ImageId: !FindInMap [AWSRegionToAMI, !Ref 'AWS::Region', AMIID]
      SecurityGroups:
        - "{{ vpcfacts.ansible_facts.cloudformation[referenced_stacks.VPCStackName].stack_outputs.SGAPP }}"
      InstanceType: "{{ ecs.cluster.instance_type }}"
      IamInstanceProfile: !Ref 'EC2InstanceProfile'
      KeyName: "{{ ecs.cluster.keypair }}"
      UserData:
        Fn::Base64:
          Fn::Sub:
          - |
            #!/bin/bash -xe
{% if ecs.efs is defined %}
            yum install -y nfs-utils
{% for fs in ecs.efs | default([]) %}
            mkdir -p fs.mountpoint
            echo -e '{{ '${' }}{{ fs.export_name }}{{ '}' }}.efs.${AWS::Region}.amazonaws.com:/ /efs nfs4 nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2 0 0' >> /etc/fstab
            mount -a
{% endfor %}
{% endif %}
            echo ECS_CLUSTER=${ECSCluster} >> /etc/ecs/ecs.config
            yum install -y aws-cfn-bootstrap
            /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource ECSAutoScalingGroup --region ${AWS::Region}
          -
{% for fs in ecs.efs | default([]) %}
            {{ fs.export_name }}:
              Fn::ImportValue:
                "{{ fs.export_name }}"
{% endfor %}


  ECSAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier:
        - "{{ vpcfacts.ansible_facts.cloudformation[referenced_stacks.VPCStackName].stack_outputs.PrivateSubnetAZ1 }}"
        - "{{ vpcfacts.ansible_facts.cloudformation[referenced_stacks.VPCStackName].stack_outputs.PrivateSubnetAZ2 }}"
        - "{{ vpcfacts.ansible_facts.cloudformation[referenced_stacks.VPCStackName].stack_outputs.PrivateSubnetAZ3 }}"
      LaunchConfigurationName: !Ref 'ContainerInstances'
      MinSize: '{{ ecs.cluster.cluster_size.min | default('1') }}'
      MaxSize: '{{ ecs.cluster.cluster_size.max | default( [ ecs.cluster.cluster_size.max, 1 ] | max ) }}'
      DesiredCapacity: '{{ ecs.cluster.cluster_size.desired | default( [ ecs.cluster.cluster_size.min, 1 ] | max ) }}'
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    UpdatePolicy:
      AutoScalingReplacingUpdate:
        WillReplace: 'true'

  ### Resources for Tasks and Services
{% for app in applicationconfig %}
{%   if app.target | lower == 'ecs' %}
  ### AWS::Logs::LogGroup for {{ app.name }}
  CloudWatch{{ cfn_project }}{{ app.cfn_name }}:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "cw-{{ project }}-{{ app.name }}"
      RetentionInDays: 14

  ### AWS::CloudWatch::MetricFilter for CloudWatch logs for application {{ app.name }}
  MetricFilterAppStart{{ cfn_project }}{{ app.cfn_name }}:
    Type: "AWS::Logs::MetricFilter"
    Properties:
      LogGroupName: !Ref CloudWatch{{ cfn_project }}{{ app.cfn_name }}
      FilterPattern: "Started Application in"
      MetricTransformations:
        - MetricValue: "1"
          MetricNamespace: "{{ cfn_project }}/ServiceStart"
          MetricName: "{{ app.cfn_name }}"

  ### AWS::CloudWatch::Alarm for MetricFilterAppStart
  AlarmAppStart{{ cfn_project }}{{ app.cfn_name }}:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: "Start Alarm for {{ cfn_project }}{{ app.cfn_name }}"
      AlarmActions:
        - !ImportValue "IxorMonitoringSubaccount-MonitoringSNSTopic"
      MetricName: "{{ app.cfn_name }}"
      Namespace: "{{ cfn_project }}/ServiceStart"
      Statistic: Average
      Period: '60'
      EvaluationPeriods: '1'
      Threshold: '1'
      ComparisonOperator: GreaterThanOrEqualToThreshold
      TreatMissingData: notBreaching

  ### AWS::ECS::TaskDefinition for {{ app.name }}
  Task{{ cfn_project }}{{ app.cfn_name }}:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: "task-{{ project }}-{{ app.name }}"
      ContainerDefinitions:
        - Name: "{{ project }}-{{ app.name }}"
          Cpu: "{{ app.ecs.cpu | default('10') }}"
          Essential: 'true'
          Image: "{{ app.ecs.image }}"
          Memory: "{{ app.ecs.memory | default(1024) }}"
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref "CloudWatch{{ cfn_project }}{{ app.cfn_name }}"
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: "{{ project }}-{{ app.name }}"
          PortMappings:
            - ContainerPort: {{ app.ecs.containerport }}
          Environment:
            - Name: Application
              Value: "{{ project }}"
{%     for env in app.environment | default([]) %}
            - Name: "{{ env.name }}"
              Value: "{{ env.value }}"
{%     endfor %}
{%     if app.ecs.task_role_arn is defined %}
      TaskRoleArn: "{{ app.ecs.task_role_arn }}"
{%     endif %}

  ### AWS::ECS::Service for {{ app.name }}
  Service{{ cfn_project }}{{ app.cfn_name }}:
    Type: AWS::ECS::Service
    Properties:
      ServiceName: "{{ project }}-{{ app.name }}"
      Cluster: !Ref 'ECSCluster'
      DesiredCount: '{{ app.ecs.desiredcount | default(1) }}'
      HealthCheckGracePeriodSeconds: "{{ app.ecs.healthcheckgraceperiodseconds | default(300) }}"
      ### The DeploymentConfiguration settings are the defaults, they were added
      ### for documentation reasons
      ### Also see https://docs.aws.amazon.com/AmazonECS/latest/developerguide/update-service.html
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      LoadBalancers:
        - ContainerName: "{{ project }}-{{ app.name }}"
          ContainerPort: "{{ app.ecs.containerport }}"
{%     for result in lbstacks.results %}
{%       if result.item.name == app.lb.name %}
{%         if app.lb.targetgroup is defined %}
          TargetGroupArn: "{{ result.stack_outputs[app.lb.targetgroup] }}"
{%         else %}
          TargetGroupArn: "{{ result.stack_outputs['TGApp' + cfn_project + result.item.name + app.cfn_name] }}"
{%         endif %}
{%       endif %}
{%     endfor %}
      Role: !Ref 'ECSServiceRole'
      TaskDefinition: !Ref "Task{{ cfn_project }}{{ app.cfn_name }}"

  ### AWS::Route53::RecordSet for {{ app.name }} in private hosted zones
{%     if route53 is defined %}
{%       for result in lbstacks.results %}
{%         if app.domains is defined and result.item.name == app.lb.name %}
{%           for domain in app.domains %}
{%             if domain.skiproute53 is not defined or not domain.skiproute53 %}
  ### {{ result.item.name }} - {{ app.lb.name }} - {{ domain.cfn_name }} - {{ domain.name }}
  Route53RecordSet{{ cfn_project }}{{ app.cfn_name }}{{ domain.cfn_name }}:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !ImportValue "{{ cfn_project }}Route53-Route53PrivateHostedZone{{ domain.cfn_name }}"
      Comment: "DNS name for {{ cfn_project }}{{ app.cfn_name }}{{ domain.cfn_name }}."
      Name: "{{ domain.listener_rule_host_header }}."
      Type: CNAME
      TTL: '300'
      ResourceRecords:
        - "{{ result.stack_outputs[app.lb.name + 'DNS'] }}"
{%             endif %}
{%           endfor %}
{%         endif %}
{%       endfor %}
{%     endif %}

{%     if app.domains is defined and route53 is defined %}
{%       for domain in app.domains %}
{%         for public_hosted_zone in route53.public_hosted_zones | default([]) %}
{%           if app.lb.type is defined and app.lb.type == 'public' and public_hosted_zone.cfn_name == domain.cfn_name %}
{%             if domain.listener_rule_host_header != domain.name %}
{%               if domain.skiproute53 is not defined or not domain.skiproute53 %}
  ### Do not create RecordSet if it is same as domainname
  ### AWS::Route53::RecordSet for {{ app.name }} in public hosted zones
  Route53PublicRecordSet{{ cfn_project }}{{ app.cfn_name }}{{ domain.cfn_name }}:
    Type: Custom::CNAME
    Properties:
      ServiceToken: {{ public_hosted_zone.sns_arn }}
      Source: {{ domain.listener_rule_host_header }}.
      Target: !ImportValue "{{ cfn_project }}LB{{ app.lb.name }}-{{ app.lb.name }}DNS"
      RecordType: CNAME
{%               endif %}
{%             endif %}
{%           endif %}
{%         endfor %}
{%       endfor %}
{%     endif %}

{%   endif %}
{% endfor %}
